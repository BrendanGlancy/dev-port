{"version":3,"file":"batching.js","sourceRoot":"","sources":["../../../src/link/batch/batching.ts"],"names":[],"mappings":"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","sourcesContent":["import { FetchResult, NextLink, Operation } from '../core';\nimport { Observable, ObservableSubscription } from '../../utilities';\n\nexport type BatchHandler = (\n  operations: Operation[],\n  forward?: (NextLink | undefined)[],\n) => Observable<FetchResult[]> | null;\n\nexport interface BatchableRequest {\n  operation: Operation;\n  forward?: NextLink;\n}\n\ntype QueuedRequest = BatchableRequest & {\n  observable?: Observable<FetchResult>;\n  next: Array<(result: FetchResult) => void>;\n  error: Array<(error: Error) => void>;\n  complete: Array<() => void>;\n  subscribers: Set<object>;\n}\n\n// Batches are primarily a Set<QueuedRequest>, but may have other optional\n// properties, such as batch.subscription.\ntype RequestBatch = Set<QueuedRequest> & {\n  subscription?: ObservableSubscription;\n}\n\n// QueryBatcher doesn't fire requests immediately. Requests that were enqueued within\n// a certain amount of time (configurable through `batchInterval`) will be batched together\n// into one query.\nexport class OperationBatcher {\n  // Queue on which the QueryBatcher will operate on a per-tick basis.\n  private batchesByKey = new Map<string, RequestBatch>();\n\n  private scheduledBatchTimer: ReturnType<typeof setTimeout>;\n  private batchDebounce?: boolean;\n  private batchInterval?: number;\n  private batchMax: number;\n\n  //This function is called to the queries in the queue to the server.\n  private batchHandler: BatchHandler;\n  private batchKey: (operation: Operation) => string;\n\n  constructor({\n    batchDebounce,\n    batchInterval,\n    batchMax,\n    batchHandler,\n    batchKey,\n  }: {\n    batchDebounce?: boolean;\n    batchInterval?: number;\n    batchMax?: number;\n    batchHandler: BatchHandler;\n    batchKey?: (operation: Operation) => string;\n  }) {\n    this.batchDebounce = batchDebounce;\n    this.batchInterval = batchInterval;\n    this.batchMax = batchMax || 0;\n    this.batchHandler = batchHandler;\n    this.batchKey = batchKey || (() => '');\n  }\n\n  public enqueueRequest(request: BatchableRequest): Observable<FetchResult> {\n    const requestCopy: QueuedRequest = {\n      ...request,\n      next: [],\n      error: [],\n      complete: [],\n      subscribers: new Set(),\n    };\n\n    const key = this.batchKey(request.operation);\n\n    if (!requestCopy.observable) {\n      requestCopy.observable = new Observable<FetchResult>(observer => {\n        let batch = this.batchesByKey.get(key)!;\n        if (!batch) this.batchesByKey.set(key, batch = new Set());\n\n        // These booleans seem to me (@benjamn) like they might always be the\n        // same (and thus we could do with only one of them), but I'm not 100%\n        // sure about that.\n        const isFirstEnqueuedRequest = batch.size === 0;\n        const isFirstSubscriber = requestCopy.subscribers.size === 0;\n        requestCopy.subscribers.add(observer);\n        if (isFirstSubscriber) {\n          batch.add(requestCopy);\n        }\n\n        // called for each subscriber, so need to save all listeners (next, error, complete)\n        if (observer.next) {\n          requestCopy.next.push(observer.next.bind(observer));\n        }\n\n        if (observer.error) {\n          requestCopy.error.push(observer.error.bind(observer));\n        }\n\n        if (observer.complete) {\n          requestCopy.complete.push(observer.complete.bind(observer));\n        }\n\n        // The first enqueued request triggers the queue consumption after `batchInterval` milliseconds.\n        if (isFirstEnqueuedRequest || this.batchDebounce) {\n          this.scheduleQueueConsumption(key);\n        }\n\n        // When amount of requests reaches `batchMax`, trigger the queue consumption without waiting on the `batchInterval`.\n        if (batch.size === this.batchMax) {\n          this.consumeQueue(key);\n        }\n\n        return () => {\n          // If this is last subscriber for this request, remove request from queue\n          if (requestCopy.subscribers.delete(observer) &&\n              requestCopy.subscribers.size < 1) {\n            // If this is last request from queue, remove queue entirely\n            if (batch.delete(requestCopy) && batch.size < 1) {\n              this.consumeQueue(key);\n              // If queue was in flight, cancel it\n              batch.subscription?.unsubscribe();\n            }\n          }\n        }\n      });\n    }\n\n    return requestCopy.observable;\n  }\n\n  // Consumes the queue.\n  // Returns a list of promises (one for each query).\n  public consumeQueue(\n    key: string = '',\n  ): (Observable<FetchResult> | undefined)[] | undefined {\n    const batch = this.batchesByKey.get(key);\n    // Delete this batch and process it below.\n    this.batchesByKey.delete(key);\n    if (!batch || !batch.size) {\n      // No requests to be processed.\n      return;\n    }\n\n    const operations: QueuedRequest['operation'][] = [];\n    const forwards: QueuedRequest['forward'][] = [];\n    const observables: QueuedRequest['observable'][] = [];\n    const nexts: QueuedRequest['next'][] = [];\n    const errors: QueuedRequest['error'][] = [];\n    const completes: QueuedRequest['complete'][] = [];\n\n    // Even though batch is a Set, it preserves the order of first insertion\n    // when iterating (per ECMAScript specification), so these requests will be\n    // handled in the order they were enqueued (minus any deleted ones).\n    batch.forEach(request => {\n      operations.push(request.operation);\n      forwards.push(request.forward);\n      observables.push(request.observable);\n      nexts.push(request.next);\n      errors.push(request.error);\n      completes.push(request.complete);\n    });\n\n    const batchedObservable =\n      this.batchHandler(operations, forwards) || Observable.of();\n\n    const onError = (error: Error) => {\n      //each callback list in batch\n      errors.forEach(rejecters => {\n        if (rejecters) {\n          //each subscriber to request\n          rejecters.forEach((e) => e(error));\n        }\n      });\n    };\n\n    batch.subscription = batchedObservable.subscribe({\n      next: results => {\n        if (!Array.isArray(results)) {\n          results = [results];\n        }\n\n        if (nexts.length !== results.length) {\n          const error = new Error(\n            `server returned results with length ${\n              results.length\n            }, expected length of ${nexts.length}`,\n          );\n          (error as any).result = results;\n\n          return onError(error);\n        }\n\n        results.forEach((result, index) => {\n          if (nexts[index]) {\n            nexts[index].forEach((next) => next(result));\n          }\n        });\n      },\n      error: onError,\n      complete: () => {\n        completes.forEach(complete => {\n          if (complete) {\n            //each subscriber to request\n            complete.forEach((c) => c());\n          }\n        });\n      },\n    });\n\n    return observables;\n  }\n\n  private scheduleQueueConsumption(key: string): void {\n    clearTimeout(this.scheduledBatchTimer);\n    this.scheduledBatchTimer = setTimeout(() => {\n      this.consumeQueue(key);\n    }, this.batchInterval);\n  }\n}\n"]}