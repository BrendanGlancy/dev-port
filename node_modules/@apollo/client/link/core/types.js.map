{"version":3,"file":"types.js","sourceRoot":"","sources":["../../../src/link/core/types.ts"],"names":[],"mappings":"","sourcesContent":["import { DocumentNode, ExecutionResult, GraphQLError } from \"graphql\";\nexport { DocumentNode };\n\nimport { Observable } from \"../../utilities\";\n\nexport type Path = ReadonlyArray<string | number>;\ntype Data<T> = T | null | undefined;\n\n\ninterface ExecutionPatchResultBase {\n  hasNext?: boolean;\n}\n\nexport interface ExecutionPatchInitialResult<\n  TData = Record<string, any>,\n  TExtensions = Record<string, any>\n> extends ExecutionPatchResultBase {\n  // if data is present, incremental is not\n  data: Data<TData>;\n  incremental?: never;\n  errors?: ReadonlyArray<GraphQLError>;\n  extensions?: TExtensions;\n}\n\nexport interface IncrementalPayload<\n  TData,\n  TExtensions,\n> {\n  // data and path must both be present\n  // https://github.com/graphql/graphql-spec/pull/742/files#diff-98d0cd153b72b63c417ad4238e8cc0d3385691ccbde7f7674bc0d2a718b896ecR288-R293\n  data: Data<TData>;\n  label?: string;\n  path: Path;\n  errors?: ReadonlyArray<GraphQLError>;\n  extensions?: TExtensions;\n}\n\nexport interface ExecutionPatchIncrementalResult<\n  TData = Record<string, any>,\n  TExtensions = Record<string, any>\n> extends ExecutionPatchResultBase {\n  // the reverse is also true: if incremental is present,\n  // data (and errors and extensions) are not\n  incremental?: IncrementalPayload<TData, TExtensions>[];\n  data?: never;\n  // Errors only exist for chunks, not at the top level\n  // https://github.com/robrichard/defer-stream-wg/discussions/50#discussioncomment-3466739\n  errors?: never;\n  extensions?: never;\n}\n\nexport type ExecutionPatchResult<\n  TData = Record<string, any>,\n  TExtensions = Record<string, any>\n> =\n  | ExecutionPatchInitialResult<TData, TExtensions>\n  | ExecutionPatchIncrementalResult<TData, TExtensions>;\n\nexport interface GraphQLRequest {\n  query: DocumentNode;\n  variables?: Record<string, any>;\n  operationName?: string;\n  context?: Record<string, any>;\n  extensions?: Record<string, any>;\n}\n\nexport interface Operation {\n  query: DocumentNode;\n  variables: Record<string, any>;\n  operationName: string;\n  extensions: Record<string, any>;\n  setContext: (context: Record<string, any>) => Record<string, any>;\n  getContext: () => Record<string, any>;\n}\n\nexport interface SingleExecutionResult<\n  TData = Record<string, any>,\n  TContext = Record<string, any>,\n  TExtensions = Record<string, any>\n> extends ExecutionResult<TData, TExtensions> {\n  data?: Data<TData>;\n  context?: TContext;\n}\n\nexport type FetchResult<\n  TData = Record<string, any>,\n  TContext = Record<string, any>,\n  TExtensions = Record<string, any>\n> =\n  | SingleExecutionResult<TData, TContext, TExtensions>\n  | ExecutionPatchResult<TData, TExtensions>;\n\nexport type NextLink = (operation: Operation) => Observable<FetchResult>;\n\nexport type RequestHandler = (\n  operation: Operation,\n  forward: NextLink\n) => Observable<FetchResult> | null;\n"]}