{"version":3,"file":"helpers.js","sourceRoot":"","sources":["../../../src/cache/inmemory/helpers.ts"],"names":[],"mappings":"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","sourcesContent":["import { DocumentNode, FragmentDefinitionNode, SelectionSetNode } from 'graphql';\n\nimport {\n  NormalizedCache,\n  InMemoryCacheConfig,\n} from './types';\n\nimport { KeyFieldsContext } from './policies';\nimport { FragmentRegistryAPI } from './fragmentRegistry';\n\nimport {\n  Reference,\n  isReference,\n  StoreValue,\n  StoreObject,\n  isField,\n  DeepMerger,\n  resultKeyNameFromField,\n  shouldInclude,\n  isNonNullObject,\n  compact,\n  FragmentMap,\n  FragmentMapFunction,\n  createFragmentMap,\n  getFragmentDefinitions,\n} from '../../utilities';\n\nexport const {\n  hasOwnProperty: hasOwn,\n} = Object.prototype;\n\nexport function isNullish(value: any): value is null | undefined {\n  return value === null || value === void 0;\n}\n\nexport const isArray: (a: any) => a is any[] | readonly any[] = Array.isArray;\n\nexport function defaultDataIdFromObject(\n  { __typename, id, _id }: Readonly<StoreObject>,\n  context?: KeyFieldsContext,\n): string | undefined {\n  if (typeof __typename === \"string\") {\n    if (context) {\n      context.keyObject =\n        !isNullish(id) ? { id } :\n        !isNullish(_id) ? { _id } :\n        void 0;\n    }\n\n    // If there is no object.id, fall back to object._id.\n    if (isNullish(id) && !isNullish(_id)) {\n      id = _id;\n    }\n\n    if (!isNullish(id)) {\n      return `${__typename}:${(\n        typeof id === \"number\" ||\n        typeof id === \"string\"\n      ) ? id : JSON.stringify(id)}`;\n    }\n  }\n}\n\nconst defaultConfig = {\n  dataIdFromObject: defaultDataIdFromObject,\n  addTypename: true,\n  resultCaching: true,\n  // Thanks to the shouldCanonizeResults helper, this should be the only line\n  // you have to change to reenable canonization by default in the future.\n  canonizeResults: false,\n};\n\nexport function normalizeConfig(config: InMemoryCacheConfig) {\n  return compact(defaultConfig, config);\n}\n\nexport function shouldCanonizeResults(\n  config: Pick<InMemoryCacheConfig, \"canonizeResults\">,\n): boolean {\n  const value = config.canonizeResults;\n  return value === void 0 ? defaultConfig.canonizeResults : value;\n}\n\nexport function getTypenameFromStoreObject(\n  store: NormalizedCache,\n  objectOrReference: StoreObject | Reference,\n): string | undefined {\n  return isReference(objectOrReference)\n    ? store.get(objectOrReference.__ref, \"__typename\") as string\n    : objectOrReference && objectOrReference.__typename;\n}\n\nexport const TypeOrFieldNameRegExp = /^[_a-z][_0-9a-z]*/i;\n\nexport function fieldNameFromStoreName(storeFieldName: string): string {\n  const match = storeFieldName.match(TypeOrFieldNameRegExp);\n  return match ? match[0] : storeFieldName;\n}\n\nexport function selectionSetMatchesResult(\n  selectionSet: SelectionSetNode,\n  result: Record<string, any>,\n  variables?: Record<string, any>,\n): boolean {\n  if (isNonNullObject(result)) {\n    return isArray(result)\n      ? result.every(item => selectionSetMatchesResult(selectionSet, item, variables))\n      : selectionSet.selections.every(field => {\n        if (isField(field) && shouldInclude(field, variables)) {\n          const key = resultKeyNameFromField(field);\n          return hasOwn.call(result, key) &&\n            (!field.selectionSet ||\n             selectionSetMatchesResult(field.selectionSet, result[key], variables));\n        }\n        // If the selection has been skipped with @skip(true) or\n        // @include(false), it should not count against the matching. If\n        // the selection is not a field, it must be a fragment (inline or\n        // named). We will determine if selectionSetMatchesResult for that\n        // fragment when we get to it, so for now we return true.\n        return true;\n      });\n  }\n  return false;\n}\n\nexport function storeValueIsStoreObject(\n  value: StoreValue,\n): value is StoreObject {\n  return isNonNullObject(value) &&\n    !isReference(value) &&\n    !isArray(value);\n}\n\nexport function makeProcessedFieldsMerger() {\n  return new DeepMerger;\n}\n\nexport function extractFragmentContext(\n  document: DocumentNode,\n  fragments?: FragmentRegistryAPI,\n): {\n  fragmentMap: FragmentMap;\n  lookupFragment: FragmentMapFunction;\n} {\n  // FragmentMap consisting only of fragments defined directly in document, not\n  // including other fragments registered in the FragmentRegistry.\n  const fragmentMap = createFragmentMap(getFragmentDefinitions(document));\n  return {\n    fragmentMap,\n    lookupFragment(name) {\n      let def: FragmentDefinitionNode | null = fragmentMap[name];\n      if (!def && fragments) {\n        def = fragments.lookup(name);\n      }\n      return def || null;\n    },\n  };\n}\n"]}