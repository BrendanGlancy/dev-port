{"version":3,"sources":["../../server/incremental-cache.ts"],"sourcesContent":["import { promises, readFileSync } from 'fs'\nimport LRUCache from 'next/dist/compiled/lru-cache'\nimport path from 'path'\nimport { PrerenderManifest } from '../build'\nimport { PRERENDER_MANIFEST } from '../shared/lib/constants'\nimport { normalizePagePath } from './normalize-page-path'\n\nfunction toRoute(pathname: string): string {\n  return pathname.replace(/\\/$/, '').replace(/\\/index$/, '') || '/'\n}\n\ninterface CachedRedirectValue {\n  kind: 'REDIRECT'\n  props: Object\n}\n\ninterface CachedPageValue {\n  kind: 'PAGE'\n  html: string\n  pageData: Object\n}\n\nexport type IncrementalCacheValue = CachedRedirectValue | CachedPageValue\n\ntype IncrementalCacheEntry = {\n  curRevalidate?: number | false\n  // milliseconds to revalidate after\n  revalidateAfter: number | false\n  isStale?: boolean\n  value: IncrementalCacheValue | null\n}\n\nexport class IncrementalCache {\n  incrementalOptions: {\n    flushToDisk?: boolean\n    pagesDir?: string\n    distDir?: string\n    dev?: boolean\n  }\n\n  prerenderManifest: PrerenderManifest\n  cache?: LRUCache<string, IncrementalCacheEntry>\n  locales?: string[]\n\n  constructor({\n    max,\n    dev,\n    distDir,\n    pagesDir,\n    flushToDisk,\n    locales,\n  }: {\n    dev: boolean\n    max?: number\n    distDir: string\n    pagesDir: string\n    flushToDisk?: boolean\n    locales?: string[]\n  }) {\n    this.incrementalOptions = {\n      dev,\n      distDir,\n      pagesDir,\n      flushToDisk:\n        !dev && (typeof flushToDisk !== 'undefined' ? flushToDisk : true),\n    }\n    this.locales = locales\n\n    if (dev) {\n      this.prerenderManifest = {\n        version: -1 as any, // letting us know this doesn't conform to spec\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: null as any, // `preview` is special case read in next-dev-server\n      }\n    } else {\n      this.prerenderManifest = JSON.parse(\n        readFileSync(path.join(distDir, PRERENDER_MANIFEST), 'utf8')\n      )\n    }\n\n    if (process.env.__NEXT_TEST_MAX_ISR_CACHE) {\n      // Allow cache size to be overridden for testing purposes\n      max = parseInt(process.env.__NEXT_TEST_MAX_ISR_CACHE, 10)\n    }\n\n    if (max) {\n      this.cache = new LRUCache({\n        max,\n        length({ value }) {\n          if (!value || value.kind === 'REDIRECT') return 25\n          // rough estimate of size of cache value\n          return value.html.length + JSON.stringify(value.pageData).length\n        },\n      })\n    }\n  }\n\n  private getSeedPath(pathname: string, ext: string): string {\n    return path.join(this.incrementalOptions.pagesDir!, `${pathname}.${ext}`)\n  }\n\n  private calculateRevalidate(\n    pathname: string,\n    fromTime: number\n  ): number | false {\n    pathname = toRoute(pathname)\n\n    // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n    if (this.incrementalOptions.dev) return new Date().getTime() - 1000\n\n    const { initialRevalidateSeconds } = this.prerenderManifest.routes[\n      pathname\n    ] || {\n      initialRevalidateSeconds: 1,\n    }\n    const revalidateAfter =\n      typeof initialRevalidateSeconds === 'number'\n        ? initialRevalidateSeconds * 1000 + fromTime\n        : initialRevalidateSeconds\n\n    return revalidateAfter\n  }\n\n  getFallback(page: string): Promise<string> {\n    page = normalizePagePath(page)\n    return promises.readFile(this.getSeedPath(page, 'html'), 'utf8')\n  }\n\n  // get data from cache if available\n  async get(pathname: string): Promise<IncrementalCacheEntry | null> {\n    if (this.incrementalOptions.dev) return null\n    pathname = normalizePagePath(pathname)\n\n    let data = this.cache && this.cache.get(pathname)\n\n    // let's check the disk for seed data\n    if (!data) {\n      if (this.prerenderManifest.notFoundRoutes.includes(pathname)) {\n        const now = Date.now()\n        const revalidateAfter = this.calculateRevalidate(pathname, now)\n        data = {\n          value: null,\n          revalidateAfter: revalidateAfter !== false ? now : false,\n        }\n      }\n\n      try {\n        const htmlPath = this.getSeedPath(pathname, 'html')\n        const html = await promises.readFile(htmlPath, 'utf8')\n        const { mtime } = await promises.stat(htmlPath)\n        const pageData = JSON.parse(\n          await promises.readFile(this.getSeedPath(pathname, 'json'), 'utf8')\n        )\n\n        data = {\n          revalidateAfter: this.calculateRevalidate(pathname, mtime.getTime()),\n          value: {\n            kind: 'PAGE',\n            html,\n            pageData,\n          },\n        }\n        if (this.cache) {\n          this.cache.set(pathname, data)\n        }\n      } catch (_) {\n        // unable to get data from disk\n      }\n    }\n    if (!data) {\n      return null\n    }\n\n    if (\n      data &&\n      data.revalidateAfter !== false &&\n      data.revalidateAfter < new Date().getTime()\n    ) {\n      data.isStale = true\n    }\n\n    const manifestPath = toRoute(pathname)\n    const manifestEntry = this.prerenderManifest.routes[manifestPath]\n\n    if (data && manifestEntry) {\n      data.curRevalidate = manifestEntry.initialRevalidateSeconds\n    }\n    return data\n  }\n\n  // populate the incremental cache with new data\n  async set(\n    pathname: string,\n    data: IncrementalCacheValue | null,\n    revalidateSeconds?: number | false\n  ) {\n    if (this.incrementalOptions.dev) return\n    if (typeof revalidateSeconds !== 'undefined') {\n      // TODO: Update this to not mutate the manifest from the\n      // build.\n      this.prerenderManifest.routes[pathname] = {\n        dataRoute: path.posix.join(\n          '/_next/data',\n          `${normalizePagePath(pathname)}.json`\n        ),\n        srcRoute: null, // FIXME: provide actual source route, however, when dynamically appending it doesn't really matter\n        initialRevalidateSeconds: revalidateSeconds,\n      }\n    }\n\n    pathname = normalizePagePath(pathname)\n    if (this.cache) {\n      this.cache.set(pathname, {\n        revalidateAfter: this.calculateRevalidate(\n          pathname,\n          new Date().getTime()\n        ),\n        value: data,\n      })\n    }\n\n    // TODO: This option needs to cease to exist unless it stops mutating the\n    // `next build` output's manifest.\n    if (this.incrementalOptions.flushToDisk && data?.kind === 'PAGE') {\n      try {\n        const seedPath = this.getSeedPath(pathname, 'html')\n        await promises.mkdir(path.dirname(seedPath), { recursive: true })\n        await promises.writeFile(seedPath, data.html, 'utf8')\n        await promises.writeFile(\n          this.getSeedPath(pathname, 'json'),\n          JSON.stringify(data.pageData),\n          'utf8'\n        )\n      } catch (error) {\n        // failed to flush to disk\n        console.warn('Failed to update prerender files for', pathname, error)\n      }\n    }\n  }\n}\n"],"names":[],"mappings":"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"}