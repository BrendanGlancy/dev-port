{"version":3,"sources":["../../../server/lib/find-page-file.ts"],"sourcesContent":["import { join, sep as pathSeparator, normalize } from 'path'\nimport chalk from 'chalk'\nimport { warn } from '../../build/output/log'\nimport { promises } from 'fs'\nimport { denormalizePagePath } from '../normalize-page-path'\nimport { fileExists } from '../../lib/file-exists'\n\nasync function isTrueCasePagePath(pagePath: string, pagesDir: string) {\n  const pageSegments = normalize(pagePath).split(pathSeparator).filter(Boolean)\n\n  const segmentExistsPromises = pageSegments.map(async (segment, i) => {\n    const segmentParentDir = join(pagesDir, ...pageSegments.slice(0, i))\n    const parentDirEntries = await promises.readdir(segmentParentDir)\n    return parentDirEntries.includes(segment)\n  })\n\n  return (await Promise.all(segmentExistsPromises)).every(Boolean)\n}\n\nexport async function findPageFile(\n  rootDir: string,\n  normalizedPagePath: string,\n  pageExtensions: string[]\n): Promise<string | null> {\n  const foundPagePaths: string[] = []\n\n  const page = denormalizePagePath(normalizedPagePath)\n\n  for (const extension of pageExtensions) {\n    if (!normalizedPagePath.endsWith('/index')) {\n      const relativePagePath = `${page}.${extension}`\n      const pagePath = join(rootDir, relativePagePath)\n\n      if (await fileExists(pagePath)) {\n        foundPagePaths.push(relativePagePath)\n      }\n    }\n\n    const relativePagePathWithIndex = join(page, `index.${extension}`)\n    const pagePathWithIndex = join(rootDir, relativePagePathWithIndex)\n    if (await fileExists(pagePathWithIndex)) {\n      foundPagePaths.push(relativePagePathWithIndex)\n    }\n  }\n\n  if (foundPagePaths.length < 1) {\n    return null\n  }\n\n  if (!(await isTrueCasePagePath(foundPagePaths[0], rootDir))) {\n    return null\n  }\n\n  if (foundPagePaths.length > 1) {\n    warn(\n      `Duplicate page detected. ${chalk.cyan(\n        join('pages', foundPagePaths[0])\n      )} and ${chalk.cyan(\n        join('pages', foundPagePaths[1])\n      )} both resolve to ${chalk.cyan(normalizedPagePath)}.`\n    )\n  }\n\n  return foundPagePaths[0]\n}\n"],"names":[],"mappings":";;;;QAmBsB,YAAY,GAAZ,YAAY;AAnBoB,GAAM,CAAN,KAAM;AAC1C,GAAO,CAAP,MAAO;AACJ,GAAwB,CAAxB,IAAwB;AACpB,GAAI,CAAJ,GAAI;AACO,GAAwB,CAAxB,kBAAwB;AACjC,GAAuB,CAAvB,WAAuB;;;;;;eAEnC,kBAAkB,CAAC,QAAgB,EAAE,QAAgB,EAAE,CAAC;IACrE,KAAK,CAAC,YAAY,OARkC,KAAM,YAQ3B,QAAQ,EAAE,KAAK,CARM,KAAM,MAQI,MAAM,CAAC,OAAO;IAE5E,KAAK,CAAC,qBAAqB,GAAG,YAAY,CAAC,GAAG,QAAQ,OAAO,EAAE,CAAC,GAAK,CAAC;QACpE,KAAK,CAAC,gBAAgB,OAX4B,KAAM,OAW1B,QAAQ,KAAK,YAAY,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC;QAClE,KAAK,CAAC,gBAAgB,SATD,GAAI,UASe,OAAO,CAAC,gBAAgB;eACzD,gBAAgB,CAAC,QAAQ,CAAC,OAAO;IAC1C,CAAC;kBAEa,OAAO,CAAC,GAAG,CAAC,qBAAqB,GAAG,KAAK,CAAC,OAAO;AACjE,CAAC;eAEqB,YAAY,CAChC,OAAe,EACf,kBAA0B,EAC1B,cAAwB,EACA,CAAC;IACzB,KAAK,CAAC,cAAc;IAEpB,KAAK,CAAC,IAAI,OAtBwB,kBAAwB,sBAsBzB,kBAAkB;SAE9C,KAAK,CAAC,SAAS,IAAI,cAAc,CAAE,CAAC;QACvC,EAAE,GAAG,kBAAkB,CAAC,QAAQ,EAAC,MAAQ,IAAG,CAAC;YAC3C,KAAK,CAAC,gBAAgB,MAAM,IAAI,CAAC,CAAC,EAAE,SAAS;YAC7C,KAAK,CAAC,QAAQ,OA/BkC,KAAM,OA+BhC,OAAO,EAAE,gBAAgB;YAE/C,EAAE,YA5BmB,WAAuB,aA4BvB,QAAQ,GAAG,CAAC;gBAC/B,cAAc,CAAC,IAAI,CAAC,gBAAgB;YACtC,CAAC;QACH,CAAC;QAED,KAAK,CAAC,yBAAyB,OAtCmB,KAAM,OAsCjB,IAAI,GAAG,MAAM,EAAE,SAAS;QAC/D,KAAK,CAAC,iBAAiB,OAvC2B,KAAM,OAuCzB,OAAO,EAAE,yBAAyB;QACjE,EAAE,YAnCqB,WAAuB,aAmCzB,iBAAiB,GAAG,CAAC;YACxC,cAAc,CAAC,IAAI,CAAC,yBAAyB;QAC/C,CAAC;IACH,CAAC;IAED,EAAE,EAAE,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;eACvB,IAAI;IACb,CAAC;IAED,EAAE,SAAU,kBAAkB,CAAC,cAAc,CAAC,CAAC,GAAG,OAAO,GAAI,CAAC;eACrD,IAAI;IACb,CAAC;IAED,EAAE,EAAE,cAAc,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;YAnDb,IAAwB,QAqDtC,yBAAyB,EAtDd,MAAO,SAsDe,IAAI,KAvDU,KAAM,QAwD/C,KAAO,GAAE,cAAc,CAAC,CAAC,IAC9B,KAAK,EAxDK,MAAO,SAwDJ,IAAI,KAzD6B,KAAM,QA0D/C,KAAO,GAAE,cAAc,CAAC,CAAC,IAC9B,iBAAiB,EA1DP,MAAO,SA0DQ,IAAI,CAAC,kBAAkB,EAAE,CAAC;IAEzD,CAAC;WAEM,cAAc,CAAC,CAAC;AACzB,CAAC"}